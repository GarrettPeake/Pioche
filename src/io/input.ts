import { Logger } from "../logging/logger";
import { HTTPMethod } from "../types";


export class Session {
    public jwt: object; // TODO: Define a JWT class
    readonly request: InboundRequest;
    readonly logger: Logger;
    readonly sessionid: string;
    websocket = {
        socket: undefined,
        connected: false,
        initialized: false,
        ended: false,
        rQueue: [],
        tQueue: [],
        config: ({} as any),
        startTime: Date.now()
    };

    constructor(request: Request | any){
        // Construct the request object based on the session
        if(request instanceof Request){
            this.request = new InboundRequest(request.clone());
        } else {
            this.request = new InboundRequest(request.request);
            this.websocket = request.websocket;
        }
        this.sessionid = this.request.headers?.["cf-ray"];
        this.logger = new Logger(this.sessionid);
    }

    /**
     * Turn this instance into a JSON string for transfer between Worker and Durable Objects
     * @returns A JSON parsable string representation of this object
     */
    async toJSON(): Promise<object>{
        return {
            websocket: this.websocket,
            request: await this.request.toJSON() // request, client, sessionid, logger all build from request
        };
    }

    /**
     * Pass through logging information to logger
     * @param info Info to be logged
     */
    async log(info: any){
        this.logger.log(info);
    }

    // TODO: Create session-attaching wrappers for asserting functions
}

export class InboundRequest {

    readonly request: Request = undefined; // DONE
    readonly method: HTTPMethod = undefined; // DONE
    readonly url: URL = undefined; // DONE
    readonly host: string = undefined;
    readonly pathname: string = undefined;
    readonly query: any = undefined;
    public params: any = undefined;
    readonly headers: Headers = undefined;
    private cache_body: string = undefined;
    private cache_json: object = undefined;

    constructor(request: Request | any){
        if(request instanceof Request){
            this.request = request.clone();
            this.headers = request.headers;
        } else {
            // JSON object will have method, url, params, headers, body
            this.headers = new Headers();
            request.headers.forEach(([name, value]) => {
                this.headers.append(name, value);
            });
            this.request = new Request(request.url, {
                body: ["GET", "HEAD"].includes(request.method) ? undefined : request.body,
                headers: this.headers,
                method: request.method
            });
            this.params = request.params;
            this.cache_body = request.body;
        }
        this.method = (request.method.toUpperCase() as HTTPMethod);
        this.url = new URL(String(request.url));
        this.host = this.url.hostname;
        this.pathname = decodeURI(this.url.pathname);
        this.query = Object.fromEntries(new URLSearchParams(this.url.search));
    }

    async body(): Promise<string>{
        if(this.cache_body === undefined)
            this.cache_body = await this.request.text();
        return this.cache_body;
    }

    async json(): Promise<any>{
        if(this.cache_json === undefined){
            if(this.cache_body === undefined)
                this.cache_body = await this.request.text();
            this.cache_json = JSON.parse(this.cache_body);
        }
        return this.cache_json;
    }

    /**
     * Turn this instance into a JSON string for transfer between Worker and Durable Objects  
     * **NOTE**: The generated string will include all data to rebuild the original request 
     * @returns A JSON representation of this object
     */
    async toJSON(): Promise<object>{
        // This should contain all information from the original request
        return {
            method: this.method,
            url: this.url.toString(),
            params: this.params, // Generated by Router
            headers: [...this.headers.entries()],
            body: await this.body()
        };
    }
}

export function AcceptContent(type: string){
    return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        descriptor.value = (...args: any) => {return "TODO: acept functionality not supported yet"};
    };
}